import http from '@ohos.net.http';
import { Constants } from './Constants';
import { StorageUtil } from './StorageUtil';

/** SSE è§£æç»“æœ */
interface ParseResult {
  chunks: string[];
  fullText: string;
}

/** HTTP Header ç»“æ„ */
interface HttpHeaders {
  Accept: string;
  'Cache-Control': string;
  Authorization?: string;
}

export class StreamHttpUtil {

  /**
   * SDK20: å°†å¯¹è±¡è½¬æ¢ä¸ºæŸ¥è¯¢å‚æ•°å­—ç¬¦ä¸²
   * ä½¿ç”¨JSONåºåˆ—åŒ–å’Œæ­£åˆ™è¡¨è¾¾å¼è§£æï¼Œå®Œå…¨é¿å…ç´¢å¼•è®¿é—®å’Œå—é™çš„æ ‡å‡†åº“
   */
  private static objectToQueryString(params: Record<string, string> | object): string {
    let result: string[] = [];
    // SDK20: ä½¿ç”¨JSONæ–¹å¼è½¬æ¢ï¼Œé€šè¿‡æ­£åˆ™è¡¨è¾¾å¼è§£æé¿å…ç´¢å¼•è®¿é—®
    try {
      // å°†å¯¹è±¡è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
      let jsonStr: string = JSON.stringify(params);
      // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…é”®å€¼å¯¹ï¼Œæ­£ç¡®å¤„ç†åŒ…å«é€—å·çš„å­—ç¬¦ä¸²å€¼
      // åŒ¹é…æ¨¡å¼: "key": "value" æˆ– "key": value
      let regex: RegExp = /"([^"]+)":\s*("([^"]*)"|([^,}]+))/g;
      let match: RegExpExecArray | null;
      
      while ((match = regex.exec(jsonStr)) !== null) {
        let key: string = match[1];
        // å€¼å¯èƒ½æ˜¯å¸¦å¼•å·çš„å­—ç¬¦ä¸²æˆ–éå­—ç¬¦ä¸²å€¼
        let value: string = match[3] !== undefined ? match[3] : match[4];
        if (value !== undefined) {
          result.push(encodeURIComponent(key) + '=' + encodeURIComponent(value.trim()));
        }
      }
    } catch (e) {
      console.error('[StreamHttpUtil] objectToQueryString error:', e);
    }

    return result.join('&');
  }

  private static extractSseContent(line: string): string {
    let t: string = line.trim();
    if (t.startsWith('data: ')) {
      return t.substring(6).trim();
    }
    if (t.startsWith('data:')) {
      return t.substring(5).trim();
    }
    return t;
  }

  private static parseToChunks(text: string): ParseResult {
    let lines: string[] = text.split('\n');
    let chunks: string[] = [];
    let fullText: string = '';
    let hasSse: boolean = false;

    for (let i = 0; i < lines.length; i++) {
      let line: string = lines[i].trim();
      if (!line) continue;

      if (line.startsWith('data:')) {
        hasSse = true;
        let content: string = StreamHttpUtil.extractSseContent(line);
        if (!content || content === '[DONE]') continue;

        chunks.push(content);
        fullText += content;
      }
    }

    if (!hasSse && text.trim()) {
      chunks.push(text.trim());
      fullText = text.trim();
    }

    return {
      chunks: chunks,
      fullText: fullText
    };
  }

  /**
   * SDK20: åˆ›å»ºæµå¼è¯·æ±‚
   * @param url è¯·æ±‚URL
   * @param params æŸ¥è¯¢å‚æ•°å¯¹è±¡ï¼ˆå¯ä»¥æ˜¯ä»»ä½•å¯¹è±¡ç±»å‹ï¼‰
   * @param onChunk æ¥æ”¶åˆ°æ•°æ®å—æ—¶çš„å›è°ƒ
   * @param onComplete æµå¼å“åº”å®Œæˆæ—¶çš„å›è°ƒ
   * @param onError å‘ç”Ÿé”™è¯¯æ—¶çš„å›è°ƒ
   */
  static async createStreamRequest(
    url: string,
    params: Record<string, string> | object,
    onChunk?: (chunk: string) => void,
    onComplete?: (fullText: string) => void,
    onError?: (error: Error) => void
  ): Promise<void> {

    let request: http.HttpRequest | null = null;

    try {
      let fullUrl: string = Constants.BASE_URL + url;
      if (params && Object.keys(params).length > 0) {
        fullUrl += '?' + StreamHttpUtil.objectToQueryString(params);
      }

      request = http.createHttp();

      let headers: HttpHeaders = {
        Accept: 'text/event-stream',
        'Cache-Control': 'no-cache'
      };

      let token: string | null = await StorageUtil.getToken();
      if (token) {
        headers.Authorization = 'Bearer ' + token;
      }

      let response: http.HttpResponse = await request.request(fullUrl, {
        method: http.RequestMethod.GET,
        header: headers,
        connectTimeout: 60000,
        readTimeout: 120000
      });

      if (!response.result) {
        if (onError) onError(new Error('Empty response'));
        return;
      }

      let responseText: string = response.result.toString();
      let parsed: ParseResult = StreamHttpUtil.parseToChunks(responseText);

      // ğŸ”¥ å…³é”®ï¼šé€æ¡è§¦å‘ onChunkï¼ŒUI æ‰ä¼šåŠ¨
      if (onChunk) {
        for (let i = 0; i < parsed.chunks.length; i++) {
          onChunk(parsed.chunks[i]);
        }
      }

      if (onComplete) {
        onComplete(parsed.fullText);
      }

    } catch (e) {
      let err: Error = e instanceof Error ? e : new Error(JSON.stringify(e));
      if (onError) onError(err);
    } finally {
      if (request) {
        try {
          request.destroy();
        } catch (_) {}
      }
    }
  }
}
